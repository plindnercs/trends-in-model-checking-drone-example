mdp

const gridSize = 4;

const rewardOnDeliveryOne = 5;
const rewardOnDeliveryTwo = 10;

// Wind Probabilities (must be smaller than 1)
// going to the left
const double pWindLeft  = 0.1;
// going to the right
const double pWindRight = 1/3; // turning point at 0.306 -> 0.307
// going up
const double pWindUp    = 0.1;// 0.0;
// going down
const double pWindDown  = 0.15;// 0.2;

// Locations
formula reachedDeliveryOne = (posX = 2) & (posY = 0);
formula reachedDeliveryTwo = (posX = 0) & (posY = 3);
formula reachedTarget = (posX = (gridSize - 1)) & (posY = (gridSize - 1));

// Compute how much drift is allowed based on current position
// For RIGHT movement
formula pDriftUpForRightMove    = (posY > 0               ? (pWindDown <= pWindUp ? pWindUp - pWindDown : 0.0) : 0.0);
formula pDriftDownForRightMove  = (posY < (gridSize - 1)  ? (pWindUp <= pWindDown ? pWindDown - pWindUp : 0.0) : 0.0);
formula pDriftLeftForRightMove  = ((pWindRight <= pWindLeft) ? (pWindLeft - pWindRight) : 0.0);
formula pTotalDriftForRightMove = pDriftUpForRightMove + pDriftDownForRightMove + pDriftLeftForRightMove;
formula pForRightMove           = 1 - pTotalDriftForRightMove;

// For DOWN movement
formula pDriftLeftForDownMove   = (posX > 0        	  ? (pWindRight <= pWindLeft ? pWindLeft - pWindRight : 0.0) : 0.0);
formula pDriftRightForDownMove  = (posX < (gridSize - 1)  ? (pWindLeft <= pWindRight ? pWindRight - pWindLeft : 0.0) : 0.0);
formula pDriveUpForDownMove     = ((pWindDown <= pWindUp) ? (pWindUp - pWindDown) : 0.0);
formula pTotalDriftForDownMove  = pDriftLeftForDownMove + pDriftRightForDownMove + pDriveUpForDownMove;
formula pForDownMove            = 1 - pTotalDriftForDownMove;


module Drone

	// Drone position
	posX : [0 .. gridSize] init 0;
	posY : [0 .. gridSize] init 0;

	// Delivery collection flags
	collectedDeliveryOne : bool init false;
	collectedDeliveryTwo : bool init false;

	// === MOVE RIGHT ===
	[right] (posX < (gridSize - 1) & !reachedTarget & (!reachedDeliveryOne | collectedDeliveryOne) & (!reachedDeliveryTwo | collectedDeliveryTwo)) ->
    		pForRightMove          : (posX' = posX + 1) +
    		pDriftLeftForRightMove : (posX' = posX)     +
    		pDriftUpForRightMove   : (posY' = posY - 1) & (posX' = posX + 1) +
    		pDriftDownForRightMove : (posY' = posY + 1) & (posX' = posX + 1);

	// === MOVE RIGHT ON DELIVERY ONE ===
	[rightOnDeliveryOne] (posX < (gridSize - 1) & !reachedTarget & (reachedDeliveryOne & !collectedDeliveryOne) & (!reachedDeliveryTwo)) ->
    		pForRightMove          : (posX' = posX + 1) & (collectedDeliveryOne' = true) +
    		pDriftLeftForRightMove : (posX' = posX)     & (collectedDeliveryOne' = true) +
    		pDriftUpForRightMove   : (posY' = posY - 1) & (posX' = posX + 1) & (collectedDeliveryOne' = true) +
    		pDriftDownForRightMove : (posY' = posY + 1) & (posX' = posX + 1) & (collectedDeliveryOne' = true);

	// === MOVE RIGHT ON DELIVERY TWO ===
	[rightOnDeliveryTwo] (posX < (gridSize - 1) & !reachedTarget & (!reachedDeliveryOne) & (reachedDeliveryTwo & !collectedDeliveryTwo)) ->
    		pForRightMove          : (posX' = posX + 1) & (collectedDeliveryTwo' = true) +
    		pDriftLeftForRightMove : (posX' = posX)     & (collectedDeliveryTwo' = true) +
    		pDriftUpForRightMove   : (posY' = posY - 1) & (posX' = posX + 1) & (collectedDeliveryTwo' = true) +
    		pDriftDownForRightMove : (posY' = posY + 1) & (posX' = posX + 1) & (collectedDeliveryTwo' = true);

	// === MOVE DOWN ===
	[down] (posY < (gridSize - 1) & !reachedTarget & (!reachedDeliveryOne | collectedDeliveryOne) & (!reachedDeliveryTwo | collectedDeliveryTwo)) ->
    		pForDownMove            : (posY' = posY + 1) +
    		pDriftLeftForDownMove   : (posX' = posX - 1) & (posY' = posY + 1) +
    		pDriftRightForDownMove  : (posX' = posX + 1) & (posY' = posY + 1) +
    		pDriveUpForDownMove     : (posY' = posY);

	// === MOVE DOWN ON DELIVERY ONE ===
	[downOnDeliveryOne] (posY < (gridSize - 1) & !reachedTarget & (reachedDeliveryOne & !collectedDeliveryOne) & (!reachedDeliveryTwo)) ->
    		pForDownMove            : (posY' = posY + 1) & (collectedDeliveryOne' = true) +
    		pDriftLeftForDownMove   : (posX' = posX - 1) & (posY' = posY + 1) & (collectedDeliveryOne' = true) +
    		pDriftRightForDownMove  : (posX' = posX + 1) & (posY' = posY + 1) & (collectedDeliveryOne' = true) +
    		pDriveUpForDownMove     : (posY' = posY)     & (collectedDeliveryOne' = true);

	// === MOVE DOWN ON DELIVERY TWO ===
	[downOnDeliveryTwo] (posY < (gridSize - 1) & !reachedTarget & (!reachedDeliveryOne) & (reachedDeliveryTwo & !collectedDeliveryTwo)) ->
    		pForDownMove            : (posY' = posY + 1) & (collectedDeliveryTwo' = true) +
    		pDriftLeftForDownMove   : (posX' = posX - 1) & (posY' = posY + 1) & (collectedDeliveryTwo' = true) +
    		pDriftRightForDownMove  : (posX' = posX + 1) & (posY' = posY + 1) & (collectedDeliveryTwo' = true) +
   		pDriveUpForDownMove     : (posY' = posY)     & (collectedDeliveryTwo' = true);

  	// === STAY IN TARGET ===
  	[] reachedTarget -> true;

endmodule

// Rewards only on collection
rewards "deliveries"
  [rightOnDeliveryOne] true : rewardOnDeliveryOne;
  [rightOnDeliveryTwo] true : rewardOnDeliveryTwo;
  [downOnDeliveryOne] true : rewardOnDeliveryOne;
  [downOnDeliveryTwo] true : rewardOnDeliveryTwo;
endrewards

label "reachedTarget" = reachedTarget;
label "collectedDeliveryOne" = (collectedDeliveryOne = true);
label "collectedDeliveryTwo" = (collectedDeliveryTwo = true);
